inline Mesh* CreateVoxelTerrain()
	{
		FastNoise noise;
		noise.SetNoiseType(FastNoise::PerlinFractal);
		float*** data = new float**[NX];
		{
			for (int i = 0; i < NX; i++)
			{
				data[i] = new float*[NY];
				for (int j = 0; j < NY; j++)
				{
					data[i][j] = new float[NZ];
				}
			}
		}

		float v = 0;
		{
			for (int i = 0; i < NX; i++)
			{
				for (int j = 0; j < NY; j++)
				{
					for (int k = 0; k < NZ; k++)
					{
						float val = 1;

						if (i == 0 || i <= NX - 1) val = 0;
						if (j == 0 || j <= NY - 1) val = 0;
						if (k == 0 || k <= NZ - 1) val = 0;

						//data[i][j][k] = val;
						data[i][j][k] = (noise.GetNoise(i * 5.0f, j * 5.0f, k * 5.f) + 0.5f) * 100.0f;
						//std::cout << data[i][j][k] << std::endl;
					}
				}
			}
		}

		int i = 0;
		int j = 0;
		int k = 0;
		int trc = 0;
		List<TRIANGLE> tris;
		TRIANGLE* triangles = new TRIANGLE[10];
		GRIDCELL grid;
		for (i = 0; i < NX - 1; i++)
		{
			for (j = 0; j < NY - 1; j++)
			{
				for (k = 0; k < NZ - 1; k++)
				{
					grid.p[0].x = (float)i;
					grid.p[0].y = (float)j;
					grid.p[0].z = (float)k;
					grid.val[0] = data[i][j][k];
					grid.p[1].x = (float)i + 1;
					grid.p[1].y = (float)j;
					grid.p[1].z = (float)k;
					grid.val[1] = data[i + 1][j][k];
					grid.p[2].x = (float)i + 1;
					grid.p[2].y = (float)j + 1;
					grid.p[2].z = (float)k;
					grid.val[2] = data[i + 1][j + 1][k];
					grid.p[3].x = (float)i;
					grid.p[3].y = (float)j + 1;
					grid.p[3].z = (float)k;
					grid.val[3] = data[i][j + 1][k];
					grid.p[4].x = (float)i;
					grid.p[4].y = (float)j;
					grid.p[4].z = (float)k + 1;
					grid.val[4] = data[i][j][k + 1];
					grid.p[5].x = (float)i + 1;
					grid.p[5].y = (float)j;
					grid.p[5].z = (float)k + 1;
					grid.val[5] = data[i + 1][j][k + 1];
					grid.p[6].x = (float)i + 1;
					grid.p[6].y = (float)j + 1;
					grid.p[6].z = (float)k + 1;
					grid.val[6] = data[i + 1][j + 1][k + 1];
					grid.p[7].x = (float)i;
					grid.p[7].y = (float)j + 1;
					grid.p[7].z = (float)k + 1;
					grid.val[7] = data[i][j + 1][k + 1];


					int triCount = Polygonise(grid, 50, triangles);
					trc += triCount;
					for (int n = 0; n < triCount; n++)
					{
						tris.push_back(triangles[n]);
					}
				}
			}
		}
		delete[] triangles;
		unsigned int vertNextId = 0;

		Mesh* mesh = new Mesh();

		for (int i = 0; i < tris.size(); i++)
		{
			TRIANGLE& tri = tris[i];

			Vector3 normal = ComputeTriangleNormal(tri.p[0], tri.p[1], tri.p[2]);

			for (int j = 0; j < 3; j++)
			{
				mesh->Vertices.push_back(tri.p[j]);
				mesh->Normals.push_back(normal);
				mesh->Indices.push_back(vertNextId++);
			}
		}

		return mesh;
	}